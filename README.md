### *Question 1*
### Hаписать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.

*Пример:*
```python
def is_even(value) -> bool:
    return value % 2 == 0
```

*Аналогичный по функциональности, но отличный по сути (even.py)*
```python
def is_even(value) -> bool:
    return value & 1 == 0
```

*Подробности:*

Увеличения или ухудшения производительности не выявлено *(возможно компилятор python-а компилирует один и тот же байт-код для этих двух функций)*.

В `примере` вычисляется остаток от деления *(если число чётное, то при делении на 2 остаток будет равен 0, иначе 1)*

В `аналогичной реализации` вычисляется битовая операция "И" *(если число чётное, то в двоичной записи младший бит этого числа будет равен 0,
иначе 1. Далее происходит сравнение младшего бита числа с еденицей - если в бите записан 0, тогда результат выражения 0 & 1 будет
равен 0 - число чётное, если записана 1, тогда 1 & 1 равняется 1 - число нечётное)*

### *Question 2*
### Написать несколько реализаций циклического буфера FIFO.

*buffer.py*
```python
class Item:
    def __init__(self, value: Any = None) -> None:
        self.value: Any = value
        self.next: 'Item' = None

class BaseBuffer:
    def __init__(self, size: int = 8) -> None:
        self.size = self._size(size)
        self.head: Item = None
        self.tail: Item = None

    def _size(self, size: int) -> int:
        ...
    
    def add(self, value: Any) -> None:
        pass

    def pop(self) -> None:
        pass

    def show(self):
        ...

class Buffer_1(BaseBuffer):
    def __init__(self, size: int = 8) -> None:
        super().__init__(size)
        self.fill: int = 0

    def add(self, value: Any) -> None:
        ...

    def pop(self) -> None:
        ...

class Buffer_2(BaseBuffer):
    def __init__(self, size: int = 8) -> None:
        super().__init__(size)
        self.is_empty = True
        self._set_default()

    def _set_default(self) -> None:
        ...

    def add(self, value: Any) -> None:
        ...

    def pop(self) -> Any:        
        ...
```

*Подробности:*

Оба буферра `Buffer_1` и `Buffer_2` имеют фиксированный размер `size`, который можно установить при создании.

`Buffer_1` по умолчанию является пустым:
1) При добавлении новых элементов, когда `fill` <= `size`, создаются новые элементы `Item`
2) При добавлении новых элементов, когда `fill` == `size`, элементы перезаписываются
   *(`tail` становится `head`, `head` становится `head.next`, и в `tail` обновляется значение `tail.value`)*
3) При удалении элементов элемент `head` удаляется

`Buffer_2` по умолчанию является заполненным *(создаются элементы `Item` в количестве равном `size`)*
1) При добавлении новых элементов, когда буфер не заполнен `tail` становится `tail.next` и в `tail` обновляется значение
   `tail.value`
2) При добавлении новых элементов, когда буфер заполнен `tail` становится `tail.next`, `head` становится `head.next` и в
   `tail` обновляется значение `tail.value`
3) При удалении элементов `head` становится `head.next`

**Преимущества** `Buffer_1`:
1) Использование памяти минимально. Новые объекты `Item` своевременно создаются и удаляются

**Преимущества** `Buffer_2`:
1) Скорость. Все объекты создаются при инициализации буфера - дальше происходит лишь перестановка указателей и значений в элементах `Item`

### *Question 3*
### Предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).

*sort.py*
```python
def merge_sort(array: list) -> None:
    def _merge_sort(array: list, start: int, end: int) -> None:
        if end - start > 0:
            middle = (start + end) // 2
            _merge_sort(array, start, middle)
            _merge_sort(array, middle + 1, end)
            _merge(array, start, middle, end)

    _merge_sort(array, 0, len(array) - 1)

def _merge(array: list, start: int, middle: int, end: int) -> None:
    ...
```

*Подробности:*

Сортировка слиянием `Merge sort` в различных случаях имеет временную сложность:
1) В наихудшем - `O(n*log(n))`
2) В наилучшем - `O(n*log(n))`
3) В среднем - `O(n*log(n))`

Затраты дополнительной памяти - `O(n)`.

Является одной из лучших реализаций сортировок, где размер массива может быть случайным *(в разумных приделах)*, а данные могут быть,
как хаотичными, так и уже отсортированными

**Возможны некоторые модификации**

Сортировка `Tim Sort` показывает лучшие результаты на случайных днных, где в сортируемом массиве имеются последовательности элементов,
находящиеся в отсортированном виде.

**Итог**

Согласно условию, где сказано, что массив может быть любого размера, а элементы могут находиться в отсортированном состоянии -
сортировка `Merge sort` будет одним из лучших решений для использования - проста в реализаии и отсортирует за приемлемое время.
