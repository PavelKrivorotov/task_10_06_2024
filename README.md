### *Question 1*
### Hаписать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.

*Пример:*
```python
def is_even(value) -> bool:
    return value % 2 == 0
```

*Аналогичный по функциональности, но отличный по сути (even.py)*
```python
def is_even(value) -> bool:
    return value & 1 == 0
```

*Подробности:*

Увеличения или ухудшения производительности не выявлено *(возможно компилятор python-а компилирует один и тот же байт-код для этих двух функций)*.

В `примере` вычисляется остаток от деления *(если число чётное, то при делении на 2 остаток будет равен 0, иначе 1)*

В `аналогичной реализации` вычисляется битовая операция "И" *(если число чётное, то в двоичной записи младший бит этого числа будет равен 0,
иначе 1. Далее происходит сравнение младшего бита числа с еденицей - если в бите записан 0, тогда результат выражения 0 & 1 будет
равен 0 - число чётное, если записана 1, тогда 1 & 1 равняется 1 - число нечётное)*

### *Question 2*
### Написать несколько реализаций циклического буфера FIFO.

*buffer.py*
```python
class Item:
    def __init__(self, value: Any = None) -> None:
        self.value: Any = value
        self.next: 'Item' = None

class BaseBuffer:
    def __init__(self, size: int = 8) -> None:
        self.size = self._size(size)
        self.head: Item = None
        self.tail: Item = None

    def _size(self, size: int) -> int:
        ...
    
    def add(self, value: Any) -> None:
        pass

    def pop(self) -> None:
        pass

    def show(self):
        ...

class Buffer_1(BaseBuffer):
    def __init__(self, size: int = 8) -> None:
        super().__init__(size)
        self.fill: int = 0

    def add(self, value: Any) -> None:
        ...

    def pop(self) -> None:
        ...

class Buffer_2(BaseBuffer):
    def __init__(self, size: int = 8) -> None:
        super().__init__(size)
        self.is_empty = True
        self._set_default()

    def _set_default(self) -> None:
        ...

    def add(self, value: Any) -> None:
        ...

    def pop(self) -> Any:        
        ...
```

*Подробности:*

Оба буферра `Buffer_1` и `Buffer_2` имеют фиксированный размер `size`, который можно установить при создании.

`Buffer_1` по умолчанию является пустым:
1) При добавлении новых элементов, когда `fill` <= `size`, создаются новые элементы `Item`
2) При добавлении новых элементов, когда `fill` == `size`, элементы перезаписываются
   *(`tail` становится `head`, `head` становится `head.next`, и в `tail` обновляется значение `tail.value`)*
3) При удалении элементов элемент `head` удаляется

`Buffer_2` по умолчанию является заполненным *(создаются элементы `Item` в количестве равном `size`)*
1) При добавлении новых элементов, когда буфер не заполнен `tail` становится `tail.next` и в `tail` обновляется значение
   `tail.value`
2) При добавлении новых элементов, когда буфер заполнен `tail` становится `tail.next`, `head` становится `head.next` и в
   `tail` обновляется значение `tail.value`
3) При удалении элементов `head` становится `head.next`

**Преимущества** `Buffer_1`:
1) Использование памяти минимально. Новые объекты `Item` своевременно создаются и удаляются

**Преимущества** `Buffer_2`:
1) Скорость. Все объекты создаются при инициализации буфера - дальше происходит лишь перестановка указателей и значений в элементах `Item`

### Question 3
